<?php
/**
 * FeedRequestGoodImages
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  Lamoda\CrptNcApiClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Национальный каталог
 *
 * API
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Lamoda\CrptNcApiClient\Model;

use \ArrayAccess;
use \Lamoda\CrptNcApiClient\ObjectSerializer;

/**
 * FeedRequestGoodImages Class Doc Comment
 *
 * @category Class
 * @package  Lamoda\CrptNcApiClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class FeedRequestGoodImages implements ModelInterface, ArrayAccess
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'FeedRequest_good_images';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'photoType' => 'string',
        'photoUrl' => 'string[]',
        'identifier' => 'string',
        'identifierType' => 'string',
        'identifierPartyId' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'photoType' => null,
        'photoUrl' => null,
        'identifier' => null,
        'identifierType' => null,
        'identifierPartyId' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'photoType' => 'photo_type',
        'photoUrl' => 'photo_url',
        'identifier' => 'identifier',
        'identifierType' => 'identifier_type',
        'identifierPartyId' => 'identifier_party_id'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'photoType' => 'setPhotoType',
        'photoUrl' => 'setPhotoUrl',
        'identifier' => 'setIdentifier',
        'identifierType' => 'setIdentifierType',
        'identifierPartyId' => 'setIdentifierPartyId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'photoType' => 'getPhotoType',
        'photoUrl' => 'getPhotoUrl',
        'identifier' => 'getIdentifier',
        'identifierType' => 'getIdentifierType',
        'identifierPartyId' => 'getIdentifierPartyId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const PHOTO_TYPE__DEFAULT = 'default';
    const PHOTO_TYPE_FACING = 'facing';
    const PHOTO_TYPE__7 = '7';
    const PHOTO_TYPE__19 = '19';
    const PHOTO_TYPE__13 = '13';
    const PHOTO_TYPE_SI1 = 'si1';
    const PHOTO_TYPE_SI2 = 'si2';
    const PHOTO_TYPE_SI3 = 'si3';
    const PHOTO_TYPE_SI4 = 'si4';
    const PHOTO_TYPE_SI5 = 'si5';
    const PHOTO_TYPE__3DS = '3ds';
    const PHOTO_TYPE_MARKETING = 'marketing';
    const PHOTO_TYPE_TEXT = 'text';
    const PHOTO_TYPE_ECOMMERCE = 'ecommerce';
    const PHOTO_TYPE_UNDEF = 'undef';
    const PHOTO_TYPE_CUBI = 'cubi';
    const IDENTIFIER_GTIN = 'gtin';
    const IDENTIFIER_SKU = 'sku';
    const IDENTIFIER_LTIN = 'ltin';
    const IDENTIFIER_BARCODE = 'barcode';
    const IDENTIFIER_TYPE_GTIN = 'gtin';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPhotoTypeAllowableValues()
    {
        return [
            self::PHOTO_TYPE__DEFAULT,
            self::PHOTO_TYPE_FACING,
            self::PHOTO_TYPE__7,
            self::PHOTO_TYPE__19,
            self::PHOTO_TYPE__13,
            self::PHOTO_TYPE_SI1,
            self::PHOTO_TYPE_SI2,
            self::PHOTO_TYPE_SI3,
            self::PHOTO_TYPE_SI4,
            self::PHOTO_TYPE_SI5,
            self::PHOTO_TYPE__3DS,
            self::PHOTO_TYPE_MARKETING,
            self::PHOTO_TYPE_TEXT,
            self::PHOTO_TYPE_ECOMMERCE,
            self::PHOTO_TYPE_UNDEF,
            self::PHOTO_TYPE_CUBI,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getIdentifierAllowableValues()
    {
        return [
            self::IDENTIFIER_GTIN,
            self::IDENTIFIER_SKU,
            self::IDENTIFIER_LTIN,
            self::IDENTIFIER_BARCODE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getIdentifierTypeAllowableValues()
    {
        return [
            self::IDENTIFIER_TYPE_GTIN,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['photoType'] = $data['photoType'] ?? null;
        $this->container['photoUrl'] = $data['photoUrl'] ?? null;
        $this->container['identifier'] = $data['identifier'] ?? null;
        $this->container['identifierType'] = $data['identifierType'] ?? null;
        $this->container['identifierPartyId'] = $data['identifierPartyId'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getPhotoTypeAllowableValues();
        if (!is_null($this->container['photoType']) && !in_array($this->container['photoType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'photoType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getIdentifierAllowableValues();
        if (!is_null($this->container['identifier']) && !in_array($this->container['identifier'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'identifier', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getIdentifierTypeAllowableValues();
        if (!is_null($this->container['identifierType']) && !in_array($this->container['identifierType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'identifierType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets photoType
     *
     * @return string|null
     */
    public function getPhotoType()
    {
        return $this->container['photoType'];
    }

    /**
     * Sets photoType
     *
     * @param string|null $photoType тип изображения (обязательный). Возможные значения default — фотография по умолчанию (вид спереди) facing — crop-фотография для планограмм (обрезанная по контуру товара) 7 — фотография товара слева 19 — фотография товара справа 13 — фотография товара сзади si1 — фотография товара сверху si2 — фотография товара снизу si3 — фотография товара в упаковке si4 — фотография товара без упаковки si5 — фотография товара внутри упаковки 3ds — 3D серия marketing — коммерческая фотография товара text — фотография текста на товаре ecommerce — e-commerce фото undef — single shot, фотография товара с не предопределенного ракурса cubi — (опционально) фотография измерения ВГХ
     *
     * @return self
     */
    public function setPhotoType($photoType)
    {
        $allowedValues = $this->getPhotoTypeAllowableValues();
        if (!is_null($photoType) && !in_array($photoType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'photoType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['photoType'] = $photoType;

        return $this;
    }

    /**
     * Gets photoUrl
     *
     * @return string[]|null
     */
    public function getPhotoUrl()
    {
        return $this->container['photoUrl'];
    }

    /**
     * Sets photoUrl
     *
     * @param string[]|null $photoUrl url, либо массив url при типе 3ds (обязательный). Ссылки на фотографии с редиректом не поддерживаются
     *
     * @return self
     */
    public function setPhotoUrl($photoUrl)
    {
        $this->container['photoUrl'] = $photoUrl;

        return $this;
    }

    /**
     * Gets identifier
     *
     * @return string|null
     */
    public function getIdentifier()
    {
        return $this->container['identifier'];
    }

    /**
     * Sets identifier
     *
     * @param string|null $identifier значение gtin/sku/ltin/barcode (необязательный). Используется для связи фотографий с идентификаторами товара
     *
     * @return self
     */
    public function setIdentifier($identifier)
    {
        $allowedValues = $this->getIdentifierAllowableValues();
        if (!is_null($identifier) && !in_array($identifier, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'identifier', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['identifier'] = $identifier;

        return $this;
    }

    /**
     * Gets identifierType
     *
     * @return string|null
     */
    public function getIdentifierType()
    {
        return $this->container['identifierType'];
    }

    /**
     * Sets identifierType
     *
     * @param string|null $identifierType тип идентификатора (обязательный, если передан identifier). Возможные значения gtin
     *
     * @return self
     */
    public function setIdentifierType($identifierType)
    {
        $allowedValues = $this->getIdentifierTypeAllowableValues();
        if (!is_null($identifierType) && !in_array($identifierType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'identifierType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['identifierType'] = $identifierType;

        return $this;
    }

    /**
     * Gets identifierPartyId
     *
     * @return string|null
     */
    public function getIdentifierPartyId()
    {
        return $this->container['identifierPartyId'];
    }

    /**
     * Sets identifierPartyId
     *
     * @param string|null $identifierPartyId идентификатор торговой сети (необязательный при типе gtin; обязательный при других типах)
     *
     * @return self
     */
    public function setIdentifierPartyId($identifierPartyId)
    {
        $this->container['identifierPartyId'] = $identifierPartyId;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


